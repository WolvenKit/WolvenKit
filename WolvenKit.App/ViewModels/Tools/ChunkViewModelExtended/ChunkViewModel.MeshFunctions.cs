using System.Collections.Generic;
using System.Linq;
using CommunityToolkit.Mvvm.Input;
using WolvenKit.App.Extensions;
using HelixToolkit.SharpDX.Core;
using WolvenKit.RED4.Types;

// ReSharper disable once CheckNamespace
namespace WolvenKit.App.ViewModels.Shell;

public partial class ChunkViewModel
{
    public const string LocalMaterialBufferPath = "localMaterialBuffer.materials";
    public const string ExternalMaterialPath = "externalMaterials";
    public const string PreloadMaterialPath = "preloadLocalMaterials";
    public const string MaterialEntryDefinitionPath = "materialEntries";

    private ChunkViewModel? FindMaterialDefinition(bool isLocal, CName? name, int? index)
    {
        if ((name is null && index is null)
            || GetRootModel() is not { ResolvedData: CMesh } rootModel
            || rootModel.GetPropertyFromPath(MaterialEntryDefinitionPath) is not ChunkViewModel entries)
        {
            return null;
        }

        return entries.TVProperties.FirstOrDefault(prop =>
            prop.ResolvedData is CMeshMaterialEntry entry
            && entry.IsLocalInstance == isLocal
            && (name == null || entry.Name == name)
            && (index == null || entry.Index == index));
    }

    private ChunkViewModel? FindLocalMaterial(int index)
    {
        if (GetRootModel() is not { ResolvedData: CMesh } rootModel)
        {
            return null;
        }

        if (rootModel.GetPropertyFromPath(LocalMaterialBufferPath) is not ChunkViewModel entries)
        {
            return null;
        }

        return entries.TVProperties.ElementAtOrDefault(index);
    }

    private ChunkViewModel? FindExternalMaterial(int index)
    {
        if (GetRootModel() is not { ResolvedData: CMesh } rootModel)
        {
            return null;
        }

        if (rootModel.GetPropertyFromPath("externalMaterials") is not ChunkViewModel entries)
        {
            return null;
        }

        return entries.TVProperties.ElementAtOrDefault(index);
    }


    public void GenerateMissingMaterials(string baseMaterial, bool isLocal, bool resolveSubstitutions)
    {
        GenerateMissingMaterialDefinitions(isLocal);
        GenerateMissingMaterialInstances(baseMaterial, isLocal, resolveSubstitutions);
    }

    private void GenerateMissingMaterialDefinitions(bool isLocal)
    {
        if (ResolvedData is not CMesh mesh)
        {
            return;
        }

        var definedMaterialNames = mesh.MaterialEntries.Select(mat => mat.Name).ToList();

        // Collect material names from appearance chunk materials
        var undefinedMaterialNames = CreateAutoGeneratedChunkMaterials(mesh.Appearances)
            .SelectMany(mA =>
                mA!.ChunkMaterials.Select(chunkMaterial => chunkMaterial.GetResolvedText() ?? "").ToArray())
            .Select((materialName) =>
                materialName.Contains('@') ? $"@{materialName.Split('@').Last()}" : materialName) // dynamic
            .Where((chunkMaterialName) => !definedMaterialNames.Contains(chunkMaterialName))
            .ToHashSet().ToList();

        if (undefinedMaterialNames.Count == 0)
        {
            return;
        }

        var matIdx = mesh.MaterialEntries.LastOrDefault(mat => mat.IsLocalInstance == isLocal)?.Index ?? -1;

        // Create material definitions
        foreach (var materialName in undefinedMaterialNames)
        {
            matIdx += 1;
            var material = new CMeshMaterialEntry()
            {
                Name = materialName, Index = (CUInt16)matIdx, IsLocalInstance = isLocal
            };
            mesh.MaterialEntries.Add(material);
        }

        GetPropertyChild("materialEntries")?.RecalculateProperties();
    }

    // Converts PreloadMaterials to regular local materials. We like them better, and this way,
    // we don't have to check all those arrays.


    private bool CanConvertPreloadMaterial() => ResolvedData is CMesh mesh &&
                                                ((mesh.PreloadLocalMaterialInstances?.Count ?? 0) > 0 ||
                                                 (mesh.PreloadExternalMaterials?.Count ?? 0) > 0);


    /// <summary>
    /// Convert to local materials - if preloadLocalMaterialInstances or preloadExternalMaterials have entries, allow converting them
    /// to the corresponding non-preload list
    /// </summary>
    [RelayCommand(CanExecute = nameof(CanConvertPreloadMaterial))]
    private void ConvertPreloadMaterials()
    {
        var resolvedData = ResolvedData is CMesh ? ResolvedData : GetRootModel().ResolvedData;
        if (resolvedData is not CMesh mesh)
        {
            return;
        }

        // Make sure these are initialized
        mesh.LocalMaterialBuffer ??= new meshMeshMaterialBuffer { Materials = [], };
        mesh.LocalMaterialBuffer.Materials ??= [];

        CArray<IMaterial> localMaterials = [];
        foreach (var iMaterial in mesh.LocalMaterialBuffer.Materials)
        {
            localMaterials.Add(iMaterial);
        }

        if (mesh.PreloadLocalMaterialInstances.Count > 0)
        {
            localMaterials.AddRange(mesh.PreloadLocalMaterialInstances.Select(h => h.Chunk).OfType<IMaterial>());

            mesh.LocalMaterialBuffer.Materials = localMaterials;

            mesh.PreloadLocalMaterialInstances.Clear();

            GetPropertyChild("preloadLocalMaterialInstances")?.RecalculateProperties();
            GetPropertyChild("localMaterialBuffer")?.GetPropertyChild("materials")?.RecalculateProperties();
            GetPropertyChild("localMaterialBuffer")?.RecalculateProperties();
            Tab?.Parent.SetIsDirty(true);
        }

        if (mesh.PreloadExternalMaterials.Count == 0)
        {
            return;
        }

        CArray<CResourceAsyncReference<IMaterial>> externalMaterials = [];
        foreach (var mat in mesh.PreloadExternalMaterials)
        {
            externalMaterials.Add(new CResourceAsyncReference<IMaterial>(mat.DepotPath));
        }

        mesh.ExternalMaterials = externalMaterials;
        mesh.PreloadExternalMaterials.Clear();

        GetPropertyChild("preloadExternalMaterials")?.RecalculateProperties();
        GetPropertyChild("externalMaterials")?.RecalculateProperties();

        Tab?.Parent.SetIsDirty(true);
    }

    private void GenerateMissingMaterialInstances(string baseMaterial, bool isLocal, bool resolveSubstitutions)
    {
        if (ResolvedData is not CMesh mesh || mesh.MaterialEntries.Count == 0)
        {
            return;
        }

        ConvertPreloadMaterials();

        var numDefinedMaterials = isLocal ? mesh.LocalMaterialBuffer.Materials.Count : mesh.ExternalMaterials.Count;

        foreach (var mat in mesh.MaterialEntries
                     .Where(entry => entry.IsLocalInstance == isLocal && entry.Index >= numDefinedMaterials))
        {
            var baseMaterialPath = resolveSubstitutions
                ? baseMaterial.Replace(@"{material}", mat.Name)
                : baseMaterial;

            if (isLocal)
            {
                mesh.LocalMaterialBuffer?.Materials.Add(new CMaterialInstance()
                {
                    BaseMaterial = new CResourceReference<IMaterial>(baseMaterialPath)
                });
            }
            else
            {
                mesh.ExternalMaterials.Add(new CResourceAsyncReference<IMaterial>(baseMaterialPath));
            }
        }

        if (isLocal)
        {
            GetPropertyChild("localMaterialBuffer")?.GetPropertyChild("materials")?.RecalculateProperties();
            GetPropertyChild("localMaterialBuffer")?.RecalculateProperties();
        }
        else
        {
            GetPropertyChild("externalMaterials")?.RecalculateProperties();
        }
    }

    private bool CanAdjustSubmeshCount() => ResolvedData is CMesh;

    [RelayCommand(CanExecute = nameof(CanAdjustSubmeshCount))]
    private void AdjustSubmeshCount()
    {
        if (ResolvedData is not CMesh mesh || mesh.Appearances.Count == 0 ||
            mesh.RenderResourceBlob.GetValue() is not rendRenderMeshBlob blob)
        {
            return;
        }

        List<rendChunk> filteredRenderChunkInfos = new();
        List<CUInt8> filteredRenderChunks = new();

        for (var i = 0; i < blob.Header.RenderChunkInfos.Count; i++)
        {
            var renderChunkInfo = blob.Header.RenderChunkInfos[i];
            // <4 vertices: an "invisible" mesh that we want to get rid of
            if (renderChunkInfo.NumVertices <= 3)
            {
                continue;
            }

            filteredRenderChunkInfos.Add(renderChunkInfo);
            if (blob.Header.RenderChunks.Count > i)
            {
                filteredRenderChunks.Add(blob.Header.RenderChunks[i]);
            }
        }

        blob.Header.RenderChunkInfos = [];
        blob.Header.RenderChunks = [];

        foreach (var renderChunkInfo in filteredRenderChunkInfos)
        {
            blob.Header.RenderChunkInfos.Add(renderChunkInfo);
        }

        foreach (var renderChunkInfo in filteredRenderChunks)
        {
            blob.Header.RenderChunks.Add(renderChunkInfo);
        }

        // Find out how many chunk meshes we have 
        var numSubmeshes = blob.Header.RenderChunkInfos.Count;
        var wasDeleted = false;
        var wasAdded = false;
        foreach (var meshAppearance in mesh.Appearances)
        {
            if (meshAppearance.GetValue() is not meshMeshAppearance appearance ||
                appearance.ChunkMaterials.Count == numSubmeshes)
            {
                continue;
            }

            var newMaterials = appearance.ChunkMaterials.Where((_, i) => i < numSubmeshes).ToList();
            if (newMaterials.Count < numSubmeshes)
            {
                var sequenceIndex =
                    GetIndexOfFirstNonRepeatingMaterial(newMaterials.Select(m => m.GetResolvedText() ?? "").ToList());

                while (newMaterials.Count < numSubmeshes)
                {
                    newMaterials.Add(newMaterials[sequenceIndex]);
                    wasAdded = true;
                    sequenceIndex = (sequenceIndex + 1) % newMaterials.Count;
                }
            }

            appearance.ChunkMaterials = new CArray<CName>();
            foreach (var t in newMaterials)
            {
                appearance.ChunkMaterials.Add(t);
            }

            wasDeleted = true;
        }

        if (wasAdded || wasDeleted)
        {
            _loggerService.Info("Chunk material counts were adjusted. You can now delete unused materials.");
            Tab?.Parent.SetIsDirty(true);
        }
        else if (!wasDeleted)
        {
            _loggerService.Info("No changes were made");
        }

        return;

        int GetIndexOfFirstNonRepeatingMaterial(List<string> materials)
        {
            int numMaterials = materials.Count;

            var materialCounts = new Dictionary<string, int>();
            foreach (var material in materials)
            {
                if (materialCounts.ContainsKey(material))
                {
                    materialCounts[material]++;
                }
                else
                {
                    materialCounts[material] = 1;
                }
            }

            int startIndex = 0;
            for (int i = 0; i < numMaterials; i++)
            {
                if (materialCounts[materials[i]] != 1)
                {
                    continue;
                }

                startIndex = i;
                break;
            }

            return startIndex;
        }
    }


    private static IEnumerable<meshMeshAppearance?> CreateAutoGeneratedChunkMaterials(
        CArray<CHandle<meshMeshAppearance>> appearanceHandles)
    {
        var appearances = appearanceHandles.Select((handle) => handle.GetValue() as meshMeshAppearance)
            .Where((i) => i != null).ToList();
        if (appearances.Count == 0)
        {
            return appearances;
        }

        var firstChunkMaterials = appearances[0]!.ChunkMaterials;
        var firstAppearanceName = appearances[0]!.Name.GetResolvedText() ?? "INVALID";
        for (var i = 1; i < appearances.Count; i++)
        {
            var appearance = appearances[i];
            if (appearance is null || appearance.ChunkMaterials.Count > 0)
            {
                continue;
            }

            var appearanceName = appearance.Name.GetResolvedText() ?? "INVALID";
            appearance.ChunkMaterials ??= [];
            for (var j = 0; j < firstChunkMaterials.Count; j++)
            {
                var newChunkMaterial =
                    (firstChunkMaterials[j].GetResolvedText() ?? "").Replace(firstAppearanceName, appearanceName);
                appearance.ChunkMaterials.Insert(j, newChunkMaterial);
            }
        }

        return appearances;
    }

    [RelayCommand]
    private void DeleteUnusedMaterials(bool suppressLogOutput = false)
    {
        if (GetRootModel() is not { ResolvedData: CMesh mesh } rootChunk)
        {
            return;
        }

        rootChunk.ConvertPreloadMaterials();

        // Support auto-generated chunk material names (psiberx magic)
        var appearances = CreateAutoGeneratedChunkMaterials(mesh.Appearances);

        // Collect material names from appearance chunk materials
        var appearanceNames = appearances
            .SelectMany(mA => mA!.ChunkMaterials.Select(chunkMaterial => chunkMaterial.GetResolvedText()).ToArray())
            .ToList();

        var localMatIdxList = mesh.MaterialEntries.Where((mE) =>
            mE.IsLocalInstance && mE.Name.GetResolvedText() is string s && appearanceNames.Contains(s)
        ).Select(me => (int)me.Index).ToList();

        var externalMatIdxList = mesh.MaterialEntries.Where((mE) =>
            !mE.IsLocalInstance && mE.Name.GetResolvedText() is string s && appearanceNames.Contains(s)
        ).Select(me => (int)me.Index).ToList();

        var numUnusedMaterials = mesh.MaterialEntries.Count - (localMatIdxList.Count + externalMatIdxList.Count);
        var numTemplateProperties = 0;

        if (!suppressLogOutput && numUnusedMaterials == 0)
        {
            _loggerService.Info("No unused materials in current mesh.");
        }

        IMaterial[] keepLocal = [];
        CResourceAsyncReference<IMaterial>[] keepExternal = [];

        if (mesh.LocalMaterialBuffer?.Materials is not null && mesh.LocalMaterialBuffer.Materials.Count > 0)
        {
            keepLocal = mesh.LocalMaterialBuffer.Materials
                .Where((material, i) => localMatIdxList.Contains(i)).ToArray();
        }

        if (mesh.ExternalMaterials is not null && mesh.ExternalMaterials.Count > 0)
        {
            keepExternal = mesh.ExternalMaterials
                .Where((material, i) => externalMatIdxList.Contains(i)).ToArray();
        }

        var usedMaterialDefinitions = mesh.MaterialEntries.Where(me =>
            (me.IsLocalInstance && localMatIdxList.Contains(me.Index)) ||
            (!me.IsLocalInstance && externalMatIdxList.Contains(me.Index))
        ).ToArray();

        if (keepLocal.Length + keepExternal.Length != usedMaterialDefinitions.Length &&
            !_appViewModel.ShowConfirmationDialog(
                "Not all remaining materials match up. Continue? (You need to validate by hand)",
                "Really delete materials?"))
        {
            return;
        }

        if (mesh.LocalMaterialBuffer?.Materials is not null)
        {
            mesh.LocalMaterialBuffer.Materials.Clear();
            foreach (var t in keepLocal)
            {
                mesh.LocalMaterialBuffer.Materials.Add(DeleteTemplatePaths(t));
            }
        }

        if (mesh.ExternalMaterials is not null)
        {
            mesh.ExternalMaterials.Clear();
            foreach (var t in keepExternal)
            {
                mesh.ExternalMaterials.Add(t);
            }
        }

        mesh.MaterialEntries.Clear();
        var localMaterialIdx = 0;
        var externalMaterialIdx = 0;
        for (var i = 0; i < usedMaterialDefinitions.Length; i++)
        {
            var t = usedMaterialDefinitions[i];
            if (t.IsLocalInstance)
            {
                t.Index = (CUInt16)localMaterialIdx;
                localMaterialIdx += 1;
            }
            else
            {
                t.Index = (CUInt16)externalMaterialIdx;
                externalMaterialIdx += 1;
            }

            t.Index = (CUInt16)i;
            mesh.MaterialEntries.Add(t);
        }

        rootChunk.RecalculateProperties();
        Tab?.Parent.SetIsDirty(true);

        rootChunk.GetPropertyChild("materialEntries")?.RecalculateProperties();

        rootChunk.GetPropertyChild("localMaterialBuffer")?.GetPropertyChild("materials")?.RecalculateProperties();
        rootChunk.GetPropertyChild("localMaterialBuffer")?.RecalculateProperties();

        rootChunk.GetPropertyChild("externalMaterials")?.RecalculateProperties();

        if (numUnusedMaterials > 0)
        {
            _loggerService.Info($"Deleted {numUnusedMaterials} unused materials.");
        }

        if (numTemplateProperties > 0)
        {
            _loggerService.Info($"Deleted {numTemplateProperties} properties from outdated templates.");
        }

        return;

        IMaterial DeleteTemplatePaths(IMaterial material)
        {
            if (material is not CMaterialInstance matInstance)
            {
                return material;
            }

            CArray<CKeyValuePair> values = [];
            foreach (var cKeyValuePair in matInstance.Values)
            {
                if (cKeyValuePair.Value is not IRedRef reference || reference.DepotPath.GetResolvedText()?.Contains(
                        "this_is_an_extra_long_path_so_you_can_better_use_010_editor_to_custom_path") is not true)
                {
                    values.Add(cKeyValuePair);
                }
                else
                {
                    numTemplateProperties += 1;
                }
            }

            matInstance.Values = values;

            return matInstance;
        }
    }



    /// <summary>
    /// Resolves dynamic appearance names and -materials.
    /// Returns a dictionary of dynamic appearance names with all possible parameters. 
    /// </summary>
    /// <example><code>
    /// { "@neon", [ "red", "blue", "green" ] }
    /// </code></example>
    public Dictionary<string, List<string>> UnDynamifyAppearances()
    {
        Dictionary<string, List<string>> ret = [];

        if (ResolvedData is not CMesh mesh || GetPropertyChild("appearances") is not ChunkViewModel appearances)
        {
            return ret;
        }

        appearances.CalculatePropertiesRecursive();

        var meshAppearances = mesh.Appearances.Select(m => m.Chunk).OfType<meshMeshAppearance>().ToList();
        var appearancesWithMaterials = meshAppearances.Where(mA => mA.ChunkMaterials.Count > 0).ToList();

        // if only the first appearance has chunks defined, then the other materials will inherit from the first
        if (meshAppearances.Count > 1 && appearancesWithMaterials.Count == 1 &&
            meshAppearances.First() is meshMeshAppearance template &&
            template.Name.GetString() is string templateName)
        {
            var templateChunkMaterials = template.ChunkMaterials.Select(s => s.ToString() ?? "").ToList();
            foreach (var mA in meshAppearances)
            {
                mA.ChunkMaterials.Clear();

                // turn materialName@neon to neon_materialName
                foreach (var chunkMaterial in templateChunkMaterials.Select(chunk =>
                             chunk.Replace(templateName, mA.Name)))
                {
                    mA.ChunkMaterials.Add(chunkMaterial);
                }
            }
        }

        // now add the dynamic materials to the list
        foreach (var mA in meshAppearances)
        {
            var chunkMaterials = mA.ChunkMaterials
                .Select(cm => cm.GetString() ?? "")
                // resolve all dynamic materials, turn red@neon into neon_red
                .Select(mat =>
                {
                    if (!mat.Contains('@'))
                    {
                        return mat;
                    }

                    var nameParts = mat.Split('@');
                    if (nameParts.Length != 2)
                    {
                        return mat;
                    }

                    ret.TryAdd(nameParts[1], []);
                    var materialName = $"{nameParts[1]}_{nameParts[0]}";
                    ret.Get(nameParts[1]).Add(materialName);
                    return materialName;
                })
                .ToList();

            mA.ChunkMaterials.Clear();
            foreach (var mat in chunkMaterials)
            {
                mA.ChunkMaterials.Add(mat);
            }
        }

        if (ret.Count != 0)
        {
            appearances.RecalculateProperties();
            foreach (var child in appearances.TVProperties)
            {
                child.RecalculateProperties();
            }
        }

        return ret;
    }
}