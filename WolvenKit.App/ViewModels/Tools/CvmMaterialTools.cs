using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using WolvenKit.App.Extensions;
using WolvenKit.App.Helpers;
using WolvenKit.App.Services;
using WolvenKit.App.ViewModels.Shell;
using WolvenKit.Common.Services;
using WolvenKit.Core.Interfaces;
using WolvenKit.RED4.Types;

namespace WolvenKit.App.ViewModels.Tools;

public class CvmMaterialTools
{
    private readonly ILoggerService _loggerService;
    private readonly INotificationService _notificationService;

    public CvmMaterialTools(
        ILoggerService loggerService,
        INotificationService notificationService
    )
    {
        _notificationService = notificationService;
        _loggerService = loggerService;
    }

    #region convert between preload and regular

    public void ConvertPreloadMaterials(ChunkViewModel? cvm, bool fromPreload = false)
    {
        var resolvedData = cvm?.ResolvedData is CMesh ? cvm.ResolvedData : cvm?.GetRootModel().ResolvedData;
        if (cvm is null || resolvedData is not CMesh mesh)
        {
            return;
        }

        var needsChanges = false;
        if (fromPreload)
        {
            FromPreload();
        }
        else
        {
            ToPreload();
        }

        if (!needsChanges)
        {
            return;
        }

        RecalculateMaterialProperties(cvm, true);
        cvm.CalculateEditorDifficultyVisibility();
        cvm.Tab?.Parent.SetIsDirty(needsChanges);

        return;

        void ToPreload()
        {
            needsChanges = mesh.LocalMaterialBuffer.Materials.Count > 0 || mesh.ExternalMaterials.Count > 0;
            if (!needsChanges)
            {
                return;
            }

            mesh.PreloadLocalMaterialInstances.AddRange(
                mesh.LocalMaterialBuffer.Materials.Select(h => new CHandle<IMaterial>() { Chunk = h }));

            mesh.LocalMaterialBuffer.Materials.Clear();

            mesh.PreloadExternalMaterials.AddRange(mesh.ExternalMaterials.Select(mat =>
                new CResourceReference<IMaterial>(mat.DepotPath, mat.Flags)));

            mesh.ExternalMaterials.Clear();
        }

        void FromPreload()
        {
            needsChanges = mesh.PreloadLocalMaterialInstances.Count > 0 || mesh.PreloadExternalMaterials.Count > 0;
            if (!needsChanges)
            {
                return;
            }

            // Make sure these are initialized
            mesh.LocalMaterialBuffer ??= new meshMeshMaterialBuffer { Materials = [], };
            mesh.LocalMaterialBuffer.Materials ??= [];

            mesh.LocalMaterialBuffer.Materials.AddRange(
                mesh.PreloadLocalMaterialInstances.Select(h => h.Chunk).OfType<IMaterial>());

            mesh.PreloadLocalMaterialInstances.Clear();
        }
    }

    #endregion

    #region helper methods and convenience

    private static void RecalculateMaterialProperties(ChunkViewModel cvm, bool refreshAll = false)
    {
        cvm.GetPropertyChild("materialEntries")?.RecalculateProperties();

        if (refreshAll || HasPreloadMaterials(cvm))
        {
            cvm.GetPropertyChild("preloadLocalMaterialInstances")?.RecalculateProperties();
            cvm.GetPropertyChild("preloadExternalMaterials")?.RecalculateProperties();
            if (!refreshAll)
            {
                return;
            }
        }

        cvm.GetPropertyChild("localMaterialBuffer")?.GetPropertyChild("materials")?.RecalculateProperties();
        cvm.GetPropertyChild("localMaterialBuffer")?.RecalculateProperties();
        cvm.GetPropertyChild("externalMaterials")?.RecalculateProperties();
    }

    public static bool HasPreloadMaterials(ChunkViewModel cvm) =>
        cvm.GetRootModel() is { ResolvedData: CMesh mesh } && HasPreloadMaterials(mesh);

    private static bool HasPreloadMaterials(CMesh mesh) =>
        mesh.PreloadExternalMaterials.Count > 1 || mesh.PreloadLocalMaterialInstances.Count > 0;

    # endregion

    public void DeleteUnusedMaterials(ChunkViewModel cvm, AppViewModel? appViewModel = null,
        bool suppressLogOutput = false)
    {
        if (cvm.GetRootModel() is not { ResolvedData: CMesh mesh } rootChunk)
        {
            return;
        }

        // Support auto-generated chunk material names (psiberx magic)
        var appearances = CreateAutoGeneratedChunkMaterials(mesh.Appearances);

        // Collect material names from appearance chunk materials
        var appearanceNames = appearances
            .SelectMany(mA => mA!.ChunkMaterials.Select(chunkMaterial => chunkMaterial.GetResolvedText()).ToArray())
            .Where(n => n is not null)
            .Select(n => n!.Contains('@') ? $"@{n.Split('@').Last()}" : n) // dynamic
            .ToList();

        var localMatIdxList = mesh.MaterialEntries.Where((mE) =>
            mE.IsLocalInstance && mE.Name.GetResolvedText() is string s &&
            appearanceNames.Contains(s, StringComparer.OrdinalIgnoreCase)
        ).Select(me => (int)me.Index).ToList();

        var externalMatIdxList = mesh.MaterialEntries.Where((mE) =>
            !mE.IsLocalInstance && mE.Name.GetResolvedText() is string s &&
            appearanceNames.Contains(s, StringComparer.OrdinalIgnoreCase)
        ).Select(me => (int)me.Index).ToList();

        var numUnusedMaterials = mesh.MaterialEntries.Count - (localMatIdxList.Count + externalMatIdxList.Count);
        var numTemplateProperties = 0;

        if (numUnusedMaterials == 0)
        {
            if (suppressLogOutput)
            {
                return;
            }

            _loggerService.Info("No unused materials in current mesh.");
            _notificationService.Info("No unused materials in current mesh.");

            return;
        }

        IMaterial[] keepLocal = [];
        CResourceAsyncReference<IMaterial>[] keepExternal = [];

        if (mesh.LocalMaterialBuffer?.Materials is not null && mesh.LocalMaterialBuffer.Materials.Count > 0)
        {
            keepLocal = mesh.LocalMaterialBuffer.Materials
                .Where((material, i) => localMatIdxList.Contains(i)).ToArray();
        }

        if (mesh.ExternalMaterials is not null && mesh.ExternalMaterials.Count > 0)
        {
            keepExternal = mesh.ExternalMaterials
                .Where((material, i) => externalMatIdxList.Contains(i)).ToArray();
        }

        var usedMaterialDefinitions = mesh.MaterialEntries.Where(me =>
            (me.IsLocalInstance && localMatIdxList.Contains(me.Index)) ||
            (!me.IsLocalInstance && externalMatIdxList.Contains(me.Index))
        ).ToArray();

        if (appViewModel is not null && keepLocal.Length + keepExternal.Length != usedMaterialDefinitions.Length &&
            !appViewModel.ShowConfirmationDialog(
                "Not all remaining materials match up. Continue? (You need to validate by hand)",
                "Really delete materials?"))
        {
            return;
        }

        // recreate material definition
        mesh.MaterialEntries.Clear();
        var localMaterialIdx = 0;
        var externalMaterialIdx = 0;
        for (var i = 0; i < usedMaterialDefinitions.Length; i++)
        {
            var t = usedMaterialDefinitions[i];
            if (t.IsLocalInstance)
            {
                t.Index = (CUInt16)localMaterialIdx;
                localMaterialIdx += 1;
            }
            else
            {
                t.Index = (CUInt16)externalMaterialIdx;
                externalMaterialIdx += 1;
            }

            t.Index = (CUInt16)i;
            mesh.MaterialEntries.Add(t);
        }

        if (HasPreloadMaterials(cvm))
        {
            DeletePreloadUnusedMaterialDefinitions();
        }
        else
        {
            DeleteUnusedMaterialDefinitions();
        }

        if (numUnusedMaterials > 0)
        {
            _loggerService.Info($"Deleted {numUnusedMaterials} unused materials.");
            _notificationService.Info($"Deleted {numUnusedMaterials} unused materials.");
        }

        if (numTemplateProperties > 0)
        {
            _loggerService.Success($"Deleted {numTemplateProperties} properties from outdated templates.");
            _notificationService.Success($"Deleted {numTemplateProperties} properties from outdated templates.");
        }

        return;

        void DeleteUnusedMaterialDefinitions()
        {
            if (mesh.LocalMaterialBuffer?.Materials is not null)
            {
                mesh.LocalMaterialBuffer.Materials.Clear();
                foreach (var t in keepLocal)
                {
                    mesh.LocalMaterialBuffer.Materials.Add(DeleteTemplatePaths(t));
                }
            }

            if (mesh.ExternalMaterials is not null)
            {
                mesh.ExternalMaterials.Clear();
                foreach (var t in keepExternal)
                {
                    mesh.ExternalMaterials.Add(t);
                }
            }

            RecalculateMaterialProperties(rootChunk);
            rootChunk.Tab?.Parent.SetIsDirty(true);
        }

        void DeletePreloadUnusedMaterialDefinitions()
        {
            if (mesh.PreloadLocalMaterialInstances is not null)
            {
                mesh.PreloadLocalMaterialInstances.Clear();
                foreach (var t in keepLocal)
                {
                    mesh.PreloadLocalMaterialInstances.Add(DeleteTemplatePaths(t));
                }
            }

            if (mesh.PreloadExternalMaterials is not null)
            {
                mesh.PreloadExternalMaterials.Clear();
                foreach (var t in keepExternal)
                {
                    mesh.PreloadExternalMaterials.Add(t);
                }
            }

            RecalculateMaterialProperties(rootChunk);
            rootChunk.Tab?.Parent.SetIsDirty(true);
        }

        IMaterial DeleteTemplatePaths(IMaterial material)
        {
            if (material is not CMaterialInstance matInstance)
            {
                return material;
            }

            CArray<CKeyValuePair> values = [];
            foreach (var cKeyValuePair in matInstance.Values)
            {
                if (cKeyValuePair.Value is not IRedRef reference || reference.DepotPath.GetResolvedText()?.Contains(
                        "this_is_an_extra_long_path_so_you_can_better_use_010_editor_to_custom_path") is not true)
                {
                    values.Add(cKeyValuePair);
                }
                else
                {
                    numTemplateProperties += 1;
                }
            }

            matInstance.Values = values;

            return matInstance;
        }
    }

    #region ArchiveXL

    public static IEnumerable<meshMeshAppearance?> CreateAutoGeneratedChunkMaterials(
        CArray<CHandle<meshMeshAppearance>> appearanceHandles)
    {
        var appearances = appearanceHandles.Select((handle) => handle.GetValue() as meshMeshAppearance)
            .Where((i) => i != null).ToList();
        if (appearances.Count == 0)
        {
            return appearances;
        }

        var firstChunkMaterials = appearances[0]!.ChunkMaterials;
        var firstAppearanceName = appearances[0]!.Name.GetResolvedText() ?? "INVALID";
        for (var i = 1; i < appearances.Count; i++)
        {
            var appearance = appearances[i];
            if (appearance is null || appearance.ChunkMaterials.Count > 0)
            {
                continue;
            }

            var appearanceName = appearance.Name.GetResolvedText() ?? "INVALID";
            appearance.ChunkMaterials ??= [];
            for (var j = 0; j < firstChunkMaterials.Count; j++)
            {
                var newChunkMaterial =
                    (firstChunkMaterials[j].GetResolvedText() ?? "").Replace(firstAppearanceName, appearanceName);
                appearance.ChunkMaterials.Insert(j, newChunkMaterial);
            }
        }

        return appearances;
    }

    #endregion

    #region generate_missing_materials

    public void GenerateMissingMaterials(ChunkViewModel cvm, string baseMaterial, bool isLocal,
        bool resolveSubstitutions)
    {
        GenerateMissingMaterialDefinitions(cvm, isLocal);
        GenerateMissingMaterialInstances(cvm, baseMaterial, isLocal, resolveSubstitutions);
    }

    private static void GenerateMissingMaterialDefinitions(ChunkViewModel cvm, bool isLocal)
    {
        if (cvm.ResolvedData is not CMesh mesh)
        {
            return;
        }

        var definedMaterialNames = mesh.MaterialEntries.Select(mat => mat.Name).ToList();

        // Collect material names from appearance chunk materials
        var undefinedMaterialNames = CreateAutoGeneratedChunkMaterials(mesh.Appearances)
            .SelectMany(mA =>
                mA!.ChunkMaterials.Select(chunkMaterial => chunkMaterial.GetResolvedText() ?? "").ToArray())
            .Select((materialName) =>
                materialName.Contains('@') ? $"@{materialName.Split('@').Last()}" : materialName) // dynamic
            .Where((chunkMaterialName) => !definedMaterialNames.Contains(chunkMaterialName))
            .ToHashSet().ToList();

        if (undefinedMaterialNames.Count == 0)
        {
            return;
        }

        var matIdx = mesh.MaterialEntries.LastOrDefault(mat => mat.IsLocalInstance == isLocal)?.Index ?? -1;

        // Create material definitions
        foreach (var materialName in undefinedMaterialNames)
        {
            matIdx += 1;
            var material = new CMeshMaterialEntry()
            {
                Name = materialName, Index = (CUInt16)matIdx, IsLocalInstance = isLocal
            };
            mesh.MaterialEntries.Add(material);
        }

        cvm.GetPropertyChild("materialEntries")?.RecalculateProperties();
    }


    private static void GenerateMissingMaterialInstances(ChunkViewModel cvm, string baseMaterial, bool isLocal,
        bool resolveSubstitutions)
    {
        if (cvm.ResolvedData is not CMesh mesh || mesh.MaterialEntries.Count == 0)
        {
            return;
        }

        var numDefinedMaterials = isLocal ? mesh.LocalMaterialBuffer.Materials.Count : mesh.ExternalMaterials.Count;
        var usePreload = HasPreloadMaterials(cvm);

        foreach (var mat in mesh.MaterialEntries
                     .Where(entry => entry.IsLocalInstance == isLocal && entry.Index >= numDefinedMaterials))
        {
            var baseMaterialPath = resolveSubstitutions
                ? baseMaterial.Replace(@"{material}", mat.Name)
                : baseMaterial;

            if (isLocal)
            {
                var materialInstance = new CMaterialInstance()
                {
                    BaseMaterial = new CResourceReference<IMaterial>(baseMaterialPath)
                };

                if (usePreload)
                {
                    mesh.PreloadLocalMaterialInstances.Add(materialInstance);
                }
                else
                {
                    mesh.LocalMaterialBuffer?.Materials.Add(materialInstance);
                }
            }
            else
            {
                if (usePreload)
                {
                    mesh.PreloadExternalMaterials.Add(new CResourceAsyncReference<IMaterial>(baseMaterialPath));
                }
                else
                {
                    mesh.ExternalMaterials.Add(new CResourceAsyncReference<IMaterial>(baseMaterialPath));
                }
            }
        }


        RecalculateMaterialProperties(cvm);
    }

    #endregion

    public void AdjustSubmeshCount(ChunkViewModel cvm)
    {
        if (cvm.ResolvedData is not CMesh mesh || mesh.Appearances.Count == 0 ||
            mesh.RenderResourceBlob.GetValue() is not rendRenderMeshBlob blob)
        {
            return;
        }

        List<rendChunk> filteredRenderChunkInfos = new();
        List<CUInt8> filteredRenderChunks = new();

        for (var i = 0; i < blob.Header.RenderChunkInfos.Count; i++)
        {
            var renderChunkInfo = blob.Header.RenderChunkInfos[i];
            // <4 vertices: an "invisible" mesh that we want to get rid of
            if (renderChunkInfo.NumVertices <= 3)
            {
                continue;
            }

            filteredRenderChunkInfos.Add(renderChunkInfo);
            if (blob.Header.RenderChunks.Count > i)
            {
                filteredRenderChunks.Add(blob.Header.RenderChunks[i]);
            }
        }

        blob.Header.RenderChunkInfos = [];
        blob.Header.RenderChunks = [];

        foreach (var renderChunkInfo in filteredRenderChunkInfos)
        {
            blob.Header.RenderChunkInfos.Add(renderChunkInfo);
        }

        foreach (var renderChunkInfo in filteredRenderChunks)
        {
            blob.Header.RenderChunks.Add(renderChunkInfo);
        }

        // Find out how many chunk meshes we have
        var numSubmeshes = blob.Header.RenderChunkInfos.Count;
        var wasDeleted = false;
        var wasAdded = false;
        foreach (var appearance in mesh.Appearances.Select(a => a.GetValue()).OfType<meshMeshAppearance>())
        {
            if (appearance.ChunkMaterials.Count == numSubmeshes || appearance.ChunkMaterials.Count == 0)
            {
                continue;
            }

            var newMaterials = appearance.ChunkMaterials.Where((_, i) => i < numSubmeshes).ToList();
            if (newMaterials.Count < numSubmeshes)
            {
                var sequenceIndex =
                    GetIndexOfFirstNonRepeatingMaterial(newMaterials.Select(m => m.GetResolvedText() ?? "").ToList());

                while (newMaterials.Count < numSubmeshes && sequenceIndex < newMaterials.Count + 1)
                {
                    newMaterials.Add(newMaterials[sequenceIndex]);
                    wasAdded = true;
                    sequenceIndex = (sequenceIndex + 1) % newMaterials.Count;
                }
            }

            appearance.ChunkMaterials = new CArray<CName>();
            foreach (var t in newMaterials)
            {
                appearance.ChunkMaterials.Add(t);
            }

            wasDeleted = true;
        }


        if (wasAdded || wasDeleted)
        {
            cvm.GetPropertyChild("appearances")?.RecalculateProperties();
            _loggerService.Success("Chunk material counts were adjusted. You can now delete unused materials.");
            _notificationService.Success("Chunk material counts were adjusted. You can now delete unused materials.");
            cvm.Tab?.Parent.SetIsDirty(true);
        }
        else if (!wasDeleted)
        {
            _loggerService.Info("Submesh counts are fine, nothing to do");
            _notificationService.Info("Submesh counts are fine, nothing to do");
        }

        return;

        int GetIndexOfFirstNonRepeatingMaterial(List<string> materials)
        {
            var numMaterials = materials.Count;

            var materialCounts = new Dictionary<string, int>();
            foreach (var material in materials.Where(material => !materialCounts.TryAdd(material, 1)))
            {
                materialCounts[material]++;
            }

            var startIndex = 0;
            for (var i = 0; i < numMaterials; i++)
            {
                if (materialCounts[materials[i]] != 1)
                {
                    continue;
                }

                startIndex = i;
                break;
            }

            return startIndex;
        }
    }

    public void UnDynamifyMaterials(ChunkViewModel? cvm)
    {
        if (cvm?.ResolvedData is not CMesh mesh ||
            cvm.GetPropertyChild("appearances") is not ChunkViewModel appearances)
        {
            return;
        }

        appearances.CalculatePropertiesRecursive();

        var templatesAndValues = ArchiveXlHelper.GetMaterialSubstitutionMap(mesh.Appearances);

        // nothing to do here
        if (templatesAndValues.Count == 0)
        {
            return;
        }

        var expandedData = ArchiveXlHelper.ExpandAppearanceTemplate(mesh.Appearances);
        appearances.Data = ArchiveXlHelper.UnDynamifyChunkNames(expandedData);

        appearances.RecalculateProperties();

        cvm.GetPropertyChild("materials")?.CalculateProperties();
        cvm.GetPropertyChild("localMaterialBuffer", "materials")?.CalculateProperties();
        cvm.GetPropertyChild("preloadLocalMaterialInstances")?.CalculateProperties();

        var hasPreload = CvmMaterialTools.HasPreloadMaterials(cvm);

        // iterate over dictionary and create new materials
        foreach (var (matName, resolvedMatNames) in templatesAndValues)
        {
            var material = mesh.MaterialEntries.FirstOrDefault(m => m.Name == $"@{matName}");
            if (material is null || GetMaterialInstance(material.Index) is not CMaterialInstance matInstance)
            {
                _loggerService.Warning($"Can't un-dynamify material: Failed to resolve {matName}");
                continue;
            }

            var baseMaterialPath = matInstance.BaseMaterial.DepotPath.GetResolvedText() ?? "";

            var maxIndex = mesh.MaterialEntries.Where(m => m.IsLocalInstance.Equals(material.IsLocalInstance))
                .Select(m => m.Index).Max();

            foreach (var newMatName in resolvedMatNames.Distinct())
            {
                maxIndex += 1;
                mesh.MaterialEntries.Add(new CMeshMaterialEntry()
                {
                    Name = $"{matName}_{newMatName}", Index = maxIndex, IsLocalInstance = material.IsLocalInstance
                });

                var newMaterialInstance = new CMaterialInstance()
                {
                    BaseMaterial = new CResourceReference<IMaterial>(
                        baseMaterialPath.Replace("{material}", newMatName).Replace("*", ""),
                        InternalEnums.EImportFlags.Default),
                };

                foreach (var cvp in matInstance.Values)
                {
                    var value = ArchiveXlHelper.UnDynamifyResourceReference(cvp.Value, newMatName);

                    newMaterialInstance.Values.Add(new CKeyValuePair(cvp.Key, value));
                }

                mesh.LocalMaterialBuffer.Materials.Add(newMaterialInstance);
            }
        }

        cvm.GetPropertyChild("materialEntries")?.RecalculateProperties();
        cvm.GetPropertyChild("localMaterialBuffer", "materials")?.RecalculateProperties();

        DeleteUnusedMaterials(cvm, null, true);
        cvm.Tab?.Parent.SetIsDirty(true);

        return;

        IMaterial? GetMaterialInstance(int idx)
        {
            return hasPreload switch
            {
                true when mesh.PreloadLocalMaterialInstances.Count > idx =>
                    mesh.PreloadLocalMaterialInstances[idx].Chunk,
                false when mesh.LocalMaterialBuffer.Materials.Count > idx =>
                    mesh.LocalMaterialBuffer.Materials[idx],
                _ => null
            };
        }
    }

    public void AddMaterialAndDefinition(ChunkViewModel cvm, string newName)
    {
        if (cvm.Parent is null)
        {
            return;
        }

        var materialEntries = cvm.Parent.GetRootModel().GetPropertyChild("materialEntries");
        if (materialEntries?.ResolvedData is not CArray<CMeshMaterialEntry> array)
        {
            return;
        }

        var isLocalInstance = cvm.Parent.ResolvedData is meshMeshMaterialBuffer ||
                              cvm.Name == ChunkViewModel.PreloadMaterialPath;

        // Add the material definition
        var lastIndex = array.LastOrDefault((e) => e.IsLocalInstance == isLocalInstance)?.Index ?? -1;
        array.Add(new CMeshMaterialEntry
        {
            Name = newName, IsLocalInstance = isLocalInstance, Index = (CUInt16)lastIndex + 1
        });

        switch (materialEntries?.ResolvedData)
        {
            case CArray<CMaterialInstance> matInstances:
                matInstances.Add(new CMaterialInstance());
                break;
            case CArray<IMaterial> matInstances:
                matInstances.Add(new CMaterialInstance());
                break;
            case CArray<CResourceAsyncReference<IMaterial>> externalMaterials:
                externalMaterials.Add(new CResourceAsyncReference<IMaterial>());
                break;
            default:
                break;
        }

        materialEntries?.RecalculateProperties();
        cvm.RecalculateProperties();
    }

    public static async Task<HashSet<ResourcePath>> GetMaterialRefsFromFile(ChunkViewModel cvm,
        IProjectManager? projectManager = null)
    {
        HashSet<ResourcePath> ret = [];

        switch (cvm.GetRootModel().ResolvedData)
        {
            case CMaterialInstance mi:
                foreach (var value in (mi.Values ?? []).OfType<CKeyValuePair>())
                {
                    switch (value.Value)
                    {
                        case IRedResourceReference rRef:
                            ret.Add(rRef.DepotPath);
                            break;
                        case IRedResourceAsyncReference raRef:
                            ret.Add(raRef.DepotPath);
                            break;
                        default:
                            break;
                    }
                }

                break;
            case Multilayer_Setup mlsetup:
                foreach (var layer in mlsetup.Layers)
                {
                    ret.Add(layer.Material.DepotPath);
                    ret.Add(layer.Microblend.DepotPath);
                }

                break;
            case CMesh mesh:
                // Why is this async?
                foreach (var externalMaterial in mesh.ExternalMaterials)
                {
                    await Task.Run(() => ret.Add(externalMaterial.DepotPath));
                }

                foreach (var externalMaterial in mesh.PreloadExternalMaterials)
                {
                    await Task.Run(() => ret.Add(externalMaterial.DepotPath));
                }

                List<CMaterialInstance> localMaterials = [];
                localMaterials.AddRange((mesh.LocalMaterialBuffer?.Materials ?? []).OfType<CMaterialInstance>());
                localMaterials.AddRange((mesh.PreloadLocalMaterialInstances ?? []).Select(h => h.Chunk)
                    .OfType<CMaterialInstance>());

                foreach (var localMaterial in localMaterials)
                {
                    ret.Add(localMaterial.BaseMaterial.DepotPath);
                    foreach (var value in localMaterial.Values)
                    {
                        switch (value.Value)
                        {
                            case IRedResourceReference rRef:
                                ret.Add(rRef.DepotPath);
                                break;
                            case IRedResourceAsyncReference raRef:
                                ret.Add(raRef.DepotPath);
                                break;
                            default:
                                break;
                        }
                    }
                }

                break;
            default:
                break;
        }

        if (projectManager?.ActiveProject?.Files is not null)
        {
            ret = ret.Where(p => !projectManager.ActiveProject.Files.Contains(p!)).ToHashSet();
        }

        return ret;
    }
}
